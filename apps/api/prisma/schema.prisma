generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  READER
  AUTHOR
  CLUB_ADMIN
  STAFF
}

enum AccountStatus {
  ACTIVE
  DISABLED
  DELETED
}

enum Tier {
  FREE
  PRO_AUTHOR
  PRO_CLUB
  PUBLISHER
}

enum MembershipRole {
  OWNER
  ADMIN
  MEMBER
  PENDING
}

enum MembershipStatus {
  PENDING
  ACTIVE
  DECLINED
  REMOVED
}

enum SwapStatus {
  REQUESTED
  ACCEPTED
  DECLINED
  DELIVERED
  VERIFIED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum BookCondition {
  NEW
  LIKE_NEW
  VERY_GOOD
  GOOD
  ACCEPTABLE
}

enum ThreadType {
  DM
  CLUB
}

enum ReportStatus {
  PENDING
  REVIEWED
  DISMISSED
}

enum JoinRules {
  OPEN
  APPROVAL
  INVITE_ONLY
}

enum PollType {
  PITCH
  BOOK
}

enum PollStatus {
  DRAFT
  OPEN
  CLOSED
  ARCHIVED
}

enum PitchStatus {
  SUBMITTED
  ACCEPTED
  REJECTED
  ARCHIVED
}

enum PointType {
  SWAP_VERIFIED
  ON_TIME_DELIVERY
  PITCH_SELECTED
  VOTE_PARTICIPATION
  REVIEW_VERIFIED
  SOCIAL_SHARE
  HOST_ACTION
  REFERRAL_ACTIVATED
  ACCOUNT_CREATED
  ONBOARDING_COMPLETED
  JOIN_CLUB
  MESSAGE_POSTED
  PITCH_CREATED
  SWAP_COMPLETED
  REWARD_REDEEMED // Points spent on rewards
  REWARD_REFUNDED // Points refunded from declined redemption
}

enum ReferralStatus {
  ISSUED
  CLAIMED
  ACTIVATED
  EXPIRED
}

enum InviteStatus {
  ACTIVE
  REVOKED
  EXPIRED
}

enum RewardType {
  PLATFORM // Managed by platform (gift cards, etc.)
  AUTHOR_CONTRIBUTED // Authors provide the reward
  FEATURE // Platform features (boosts, badges, etc.)
  DIGITAL // Digital items (ebooks, etc.)
}

enum RedemptionStatus {
  PENDING
  APPROVED
  DECLINED
  FULFILLED
  CANCELLED
}

enum NotificationType {
  POLL_CREATED
  POLL_CLOSING
  PITCH_ACCEPTED
  PITCH_REJECTED
  SWAP_DELIVERED
  SWAP_VERIFIED
  SWAP_REVIEW_REMINDER
  REFERRAL_ACTIVATED
  POINTS_AWARDED
  MEMBERSHIP_APPROVED
  NEW_MESSAGE
  AUTHOR_NEW_PITCH
}

enum CreditTransactionType {
  PURCHASE
  BOOST_PITCH
  SPONSOR_CLUB
  REFUND
}

enum BookFormat {
  PAPERBACK
  HARDCOVER
  EBOOK
  AUDIOBOOK
}

// Models
model User {
  id                       String        @id
  email                    String        @unique
  name                     String
  avatarUrl                String?
  bio                      String?
  roles                    UserRole[]    @default([READER])
  tier                     Tier          @default(FREE)
  accountStatus            AccountStatus @default(ACTIVE)
  disabledAt               DateTime?
  deletedAt                DateTime?
  stripeCustomerId         String?
  stripeSubscriptionId     String?
  creditBalance            Int           @default(0) // Promotion credits for visibility boosts
  aiCallsToday             Int           @default(0)
  aiCallsResetAt           DateTime      @default(now())
  points                   Int           @default(0)
  reputation               Int           @default(0) // Legacy field - kept for backward compatibility
  reputationScore          Float         @default(0) // Averaged swap rating score (0-5)
  reputationCount          Int           @default(0) // Number of swap ratings received
  swapsCompleted           Int           @default(0) // Number of verified swaps
  emailVerified            Boolean       @default(false)
  emailVerificationToken   String?
  emailVerificationExpires DateTime?
  passwordResetToken       String?
  passwordResetExpires     DateTime?
  createdAt                DateTime      @default(now())
  updatedAt                DateTime      @updatedAt

  // Relations
  profile             UserProfile?
  books               Book[]              @relation("UserBooks")
  clubsCreated        Club[]              @relation("ClubCreator")
  memberships         Membership[]
  swapsRequested      Swap[]              @relation("SwapRequester")
  swapsReceived       Swap[]              @relation("SwapResponder")
  reviewsGiven        Review[]            @relation("Reviewer")
  reviewsReceived     Review[]            @relation("Reviewee")
  swapRatingsGiven    SwapRating[]        @relation("SwapRatingGiven")
  swapRatingsReceived SwapRating[]        @relation("SwapRatingReceived")
  payments            Payment[]
  membershipsInvited  Membership[]        @relation("InvitedBy")
  threadMemberships   ThreadMember[]
  sentMessages        Message[]
  reviewedMessages    Message[]           @relation("ReviewedMessages")
  reportedMessages    ModerationReport[]  @relation("ReportedMessages")
  reviewedReports     ModerationReport[]  @relation("ReviewedReports")
  pitches             Pitch[]
  pitchNominations    PitchNomination[]
  pointEntries        PointLedger[]
  votes               Vote[]
  pollsCreated        Poll[]
  referralsGiven      Referral[]          @relation("ReferrerReferrals")
  referralsUsed       Referral[]          @relation("RefereeReferrals")
  notifications       Notification[]
  settings            UserSetting?
  following           AuthorFollow[]      @relation("Follower")
  followers           AuthorFollow[]      @relation("FollowedAuthor")
  checklistProgress   ChecklistProgress[]
  emailLogs           EmailLog[]
  clubMessages        ClubMessage[]
  badges              UserBadge[]
  dailyCounters       DailyPointCounter[]
  creditTransactions  CreditTransaction[]
  sponsoredPitches    SponsoredPitch[]
  clubInvitesCreated  ClubInvite[]        @relation("ClubInviteCreator")
  rewardContributions RewardItem[]        @relation("RewardContributor")
  redemptions         RedemptionRequest[] @relation("UserRedemptions")
  reviewedRedemptions RedemptionRequest[] @relation("RedemptionReviewer")

  @@index([roles])
  @@index([tier])
  @@map("users")
}

model UserProfile {
  userId        String   @id
  genres        String[] @default([])
  booksPerMonth Int?
  bio           String?  @db.Text
  avatarUrl     String?
  openToSwaps   Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model Book {
  id           String        @id @default(uuid())
  ownerId      String
  title        String
  subtitle     String?
  author       String
  genres       String[]      @default([])
  isbn         String?
  description  String?
  condition    BookCondition @default(GOOD)
  imageUrl     String?
  isAvailable  Boolean       @default(true)
  // Review tracking URLs (provided by author for readers to leave reviews)
  goodreadsUrl String?
  amazonUrl    String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Relations
  owner          User         @relation("UserBooks", fields: [ownerId], references: [id], onDelete: Cascade)
  swapsOffered   Swap[]       @relation("BookOffered")
  swapsRequested Swap[]       @relation("BookRequested")
  embeddings     Embedding[]
  reviews        Review[]
  pitches        Pitch[]
  pollOptions    PollOption[]
  clubBooks      ClubBook[]

  @@index([ownerId])
  @@index([isAvailable])
  @@map("books")
}

model Club {
  id              String    @id @default(uuid())
  name            String
  description     String?
  about           String?   @db.Text
  preferredGenres String[]  @default([])
  frequency       Int?
  imageUrl        String?
  coverImageUrl   String?
  createdById     String
  maxMembers      Int       @default(50)
  isPublic        Boolean   @default(true)
  joinRules       JoinRules @default(OPEN)
  minPointsToJoin Int       @default(0)
  inviteCode      String?   @unique
  chosenBookId    String?
  chosenBookAt    DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  createdBy      User            @relation("ClubCreator", fields: [createdById], references: [id])
  memberships    Membership[]
  embeddings     Embedding[]
  messageThreads MessageThread[]
  pitches        Pitch[]
  polls          Poll[]
  messages       ClubMessage[]
  clubBooks      ClubBook[]
  invites        ClubInvite[]

  @@index([createdById])
  @@index([isPublic])
  @@index([inviteCode])
  @@map("clubs")
}

// Tracks books each club has selected for reading (allows readers to review)
model ClubBook {
  id         String   @id @default(uuid())
  clubId     String
  bookId     String
  pollId     String? // Optional: which poll selected this book
  selectedAt DateTime @default(now())
  createdAt  DateTime @default(now())

  // Relations
  club    Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  book    Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  poll    Poll?    @relation(fields: [pollId], references: [id], onDelete: SetNull)
  reviews Review[]

  @@unique([clubId, bookId]) // Each book can only be selected once per club
  @@index([clubId])
  @@index([bookId])
  @@map("club_books")
}

model ClubMessage {
  id             String   @id @default(uuid())
  clubId         String
  userId         String
  body           String   @db.Text
  attachmentUrl  String?  @db.Text
  attachmentType String?
  attachmentName String?
  createdAt      DateTime @default(now())

  // Relations
  club   Club @relation(fields: [clubId], references: [id], onDelete: Cascade)
  author User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([clubId, createdAt])
  @@map("club_messages")
}

model ClubInvite {
  id          String       @id @default(uuid())
  clubId      String
  code        String       @unique
  createdById String
  status      InviteStatus @default(ACTIVE)
  expiresAt   DateTime?
  maxUses     Int?
  usesCount   Int          @default(0)
  lastUsedAt  DateTime?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  club        Club         @relation(fields: [clubId], references: [id], onDelete: Cascade)
  creator     User         @relation("ClubInviteCreator", fields: [createdById], references: [id], onDelete: Cascade)
  memberships Membership[]

  @@index([clubId, status])
  @@index([code])
  @@map("club_invites")
}

model Membership {
  id           String           @id @default(uuid())
  userId       String
  clubId       String
  role         MembershipRole   @default(PENDING)
  status       MembershipStatus @default(PENDING)
  permissions  Json?
  joinedAt     DateTime         @default(now())
  invitedBy    String?
  invitationId String?

  // Relations
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  club       Club        @relation(fields: [clubId], references: [id], onDelete: Cascade)
  inviter    User?       @relation("InvitedBy", fields: [invitedBy], references: [id])
  invitation ClubInvite? @relation(fields: [invitationId], references: [id], onDelete: SetNull)

  @@unique([clubId, userId])
  @@index([userId])
  @@index([clubId])
  @@index([status])
  @@map("memberships")
}

model Swap {
  id              String     @id @default(uuid())
  requesterId     String
  bookOfferedId   String
  responderId     String
  bookRequestedId String
  status          SwapStatus @default(REQUESTED)
  message         String?
  dueDate         DateTime?
  deliverable     String?
  isAuthorSwap    Boolean    @default(false) // True if both parties are authors (AuthorSwap network)
  deliveredAt     DateTime? // Timestamp when status changed to DELIVERED
  verifiedAt      DateTime? // Timestamp when status changed to VERIFIED
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  requester     User         @relation("SwapRequester", fields: [requesterId], references: [id])
  responder     User         @relation("SwapResponder", fields: [responderId], references: [id])
  bookOffered   Book         @relation("BookOffered", fields: [bookOfferedId], references: [id])
  bookRequested Book         @relation("BookRequested", fields: [bookRequestedId], references: [id])
  reviews       Review[]
  payments      Payment[]
  swapRatings   SwapRating[]

  @@index([requesterId])
  @@index([responderId])
  @@index([bookOfferedId])
  @@index([bookRequestedId])
  @@index([status])
  @@map("swaps")
}

model SwapRating {
  id              String   @id @default(uuid())
  swapId          String
  raterId         String   // Who's giving the rating
  ratedUserId     String   // Who's being rated
  overallRating   Int      // 1-5 overall experience
  onTime          Boolean  // Did they complete on time?
  bookCondition   Int      // 1-5 book condition rating
  communication   Int      // 1-5 communication quality
  comment         String?  @db.Text
  createdAt       DateTime @default(now())

  // Relations
  swap      Swap @relation(fields: [swapId], references: [id], onDelete: Cascade)
  rater     User @relation("SwapRatingGiven", fields: [raterId], references: [id], onDelete: Cascade)
  ratedUser User @relation("SwapRatingReceived", fields: [ratedUserId], references: [id], onDelete: Cascade)

  @@unique([swapId, raterId]) // Each person can only rate once per swap
  @@index([raterId])
  @@index([ratedUserId])
  @@index([swapId])
  @@map("swap_ratings")
}

model Review {
  id           String   @id @default(uuid())
  reviewerId   String
  revieweeId   String? // Null for club reviews (no specific reviewee)
  swapId       String? // Null for club reviews
  clubBookId   String? // Set for club-based reviews
  bookId       String
  rating       Int // 1-5
  reviewUrl    String // REQUIRED: URL to Goodreads/Amazon review
  platform     String // REQUIRED: "goodreads" or "amazon"
  verifiedSwap Boolean  @default(false) // For author swap reviews
  createdAt    DateTime @default(now())

  // Relations
  reviewer User      @relation("Reviewer", fields: [reviewerId], references: [id])
  reviewee User?     @relation("Reviewee", fields: [revieweeId], references: [id])
  swap     Swap?     @relation(fields: [swapId], references: [id], onDelete: Cascade)
  clubBook ClubBook? @relation(fields: [clubBookId], references: [id], onDelete: Cascade)
  book     Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([swapId, reviewerId], map: "unique_swap_review") // One review per swap per reviewer
  @@unique([clubBookId, reviewerId], map: "unique_club_review") // One review per club book per reader
  @@index([reviewerId])
  @@index([revieweeId])
  @@index([bookId])
  @@index([clubBookId])
  @@map("reviews")
}

model MessageThread {
  id        String     @id @default(uuid())
  type      ThreadType
  clubId    String?
  createdAt DateTime   @default(now())

  // Relations
  members  ThreadMember[]
  messages Message[]
  club     Club?          @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@index([clubId])
  @@index([type])
  @@map("message_threads")
}

model ThreadMember {
  id         String    @id @default(uuid())
  threadId   String
  userId     String
  joinedAt   DateTime  @default(now())
  lastReadAt DateTime?

  // Relations
  thread MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId])
  @@index([threadId])
  @@map("thread_members")
}

model Message {
  id         String    @id @default(uuid())
  threadId   String
  senderId   String
  content    String    @db.Text
  createdAt  DateTime  @default(now())
  deletedAt  DateTime?
  flaggedAt  DateTime?
  reviewedBy String?
  reviewedAt DateTime?

  // Relations
  thread   MessageThread      @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender   User               @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reviewer User?              @relation("ReviewedMessages", fields: [reviewedBy], references: [id])
  reports  ModerationReport[]

  @@index([threadId, createdAt])
  @@index([senderId])
  @@index([flaggedAt])
  @@map("messages")
}

model ModerationReport {
  id         String       @id @default(uuid())
  messageId  String
  reporterId String
  reason     String       @db.Text
  status     ReportStatus @default(PENDING)
  reviewedBy String?
  reviewedAt DateTime?
  createdAt  DateTime     @default(now())

  // Relations
  message  Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  reporter User    @relation("ReportedMessages", fields: [reporterId], references: [id])
  reviewer User?   @relation("ReviewedReports", fields: [reviewedBy], references: [id])

  @@index([messageId])
  @@index([status])
  @@index([reporterId])
  @@map("moderation_reports")
}

model Payment {
  id              String        @id @default(uuid())
  userId          String
  swapId          String?
  amount          Int // in cents
  stripePaymentId String        @unique
  plan            Tier
  status          PaymentStatus @default(PENDING)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  user User  @relation(fields: [userId], references: [id])
  swap Swap? @relation(fields: [swapId], references: [id])

  @@index([userId])
  @@index([swapId])
  @@index([status])
  @@map("payments")
}

model Embedding {
  id         String   @id @default(uuid())
  entityType String // "BOOK" or "CLUB"
  bookId     String?
  clubId     String?
  embedding  String // JSON stringified vector
  createdAt  DateTime @default(now())

  // Relations
  book Book? @relation(fields: [bookId], references: [id], onDelete: Cascade)
  club Club? @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([bookId])
  @@unique([clubId])
  @@index([entityType])
  @@map("embeddings")
}

model Pitch {
  id                String      @id @default(uuid())
  authorId          String
  bookId            String
  targetClubId      String?
  title             String
  synopsis          String?     @db.Text
  sampleUrl         String?
  // New pitch enhancement fields
  genres            String[]    @default([]) // Up to 3 genres
  theme             String?     @db.Text // Book theme/topic
  imageUrl          String? // Pitch cover image
  videoUrl          String? // YouTube video URL
  // Format availability and free offer
  availableFormats  String[]    @default([]) // BookFormat enum values (PAPERBACK, HARDCOVER, EBOOK, AUDIOBOOK)
  offerFreeIfChosen Boolean     @default(false) // Author commits to provide book for free if selected
  status            PitchStatus @default(SUBMITTED)
  impressions       Int         @default(0)
  // Visibility boost fields
  isBoosted         Boolean     @default(false)
  boostEndsAt       DateTime?
  // Denormalized author tier for efficient sorting (synced on pitch creation & tier changes)
  authorTier        Tier        @default(FREE)
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Relations
  author             User                @relation(fields: [authorId], references: [id], onDelete: Cascade)
  book               Book                @relation(fields: [bookId], references: [id], onDelete: Cascade)
  targetClub         Club?               @relation(fields: [targetClubId], references: [id], onDelete: Cascade)
  pollOptions        PollOption[]
  nominations        PitchNomination[]
  sponsorships       SponsoredPitch[]
  creditTransactions CreditTransaction[]

  @@index([authorId])
  @@index([bookId])
  @@index([targetClubId])
  @@index([status])
  @@index([isBoosted])
  @@map("pitches")
}

model PitchNomination {
  id        String   @id @default(uuid())
  pitchId   String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  pitch Pitch @relation(fields: [pitchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pitchId, userId])
  @@index([pitchId])
  @@index([userId])
  @@map("pitch_nominations")
}

model Poll {
  id        String     @id @default(uuid())
  clubId    String
  type      PollType
  status    PollStatus @default(DRAFT)
  opensAt   DateTime?
  closesAt  DateTime?
  createdBy String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  club      Club         @relation(fields: [clubId], references: [id], onDelete: Cascade)
  creator   User         @relation(fields: [createdBy], references: [id])
  options   PollOption[]
  votes     Vote[]
  clubBooks ClubBook[]

  @@index([clubId])
  @@index([status])
  @@index([createdBy])
  @@map("polls")
}

model PollOption {
  id      String  @id @default(uuid())
  pollId  String
  pitchId String?
  bookId  String?
  label   String

  // Relations
  poll  Poll   @relation(fields: [pollId], references: [id], onDelete: Cascade)
  pitch Pitch? @relation(fields: [pitchId], references: [id], onDelete: Cascade)
  book  Book?  @relation(fields: [bookId], references: [id], onDelete: Cascade)
  votes Vote[]

  @@index([pollId])
  @@index([pitchId])
  @@index([bookId])
  @@map("poll_options")
}

model Vote {
  id        String   @id @default(uuid())
  pollId    String
  userId    String
  optionId  String
  createdAt DateTime @default(now())

  // Relations
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  user   User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  option PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId])
  @@index([userId])
  @@index([optionId])
  @@map("votes")
}

model PointLedger {
  id        String    @id @default(uuid())
  userId    String
  type      PointType
  amount    Int
  refType   String?
  refId     String?
  createdAt DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type, refType, refId])
  @@index([userId])
  @@index([type])
  @@map("point_ledger")
}

model Referral {
  id          String         @id @default(uuid())
  referrerId  String
  refereeId   String?
  code        String         @unique
  status      ReferralStatus @default(ISSUED)
  activatedAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  referrer User  @relation("ReferrerReferrals", fields: [referrerId], references: [id], onDelete: Cascade)
  referee  User? @relation("RefereeReferrals", fields: [refereeId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([code])
  @@index([status])
  @@map("referrals")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  data      Json
  readAt    DateTime?
  createdAt DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([createdAt])
  @@map("notifications")
}

model UserSetting {
  userId             String   @id
  emailOptIn         Boolean  @default(true)
  emailPollReminders Boolean  @default(true)
  emailSwapUpdates   Boolean  @default(true)
  emailPointsUpdates Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model ChecklistProgress {
  id      String   @id @default(uuid())
  userId  String
  code    String
  stepKey String
  doneAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, code, stepKey])
  @@index([userId, code])
  @@map("checklist_progress")
}

model EmailLog {
  id        String   @id @default(uuid())
  userId    String
  emailType String
  sentAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, emailType, sentAt])
  @@map("email_logs")
}

model UserBadge {
  id        String   @id @default(uuid())
  userId    String
  code      String
  awardedAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, code])
  @@index([userId])
  @@map("user_badges")
}

model DailyPointCounter {
  id     String    @id @default(uuid())
  userId String
  type   PointType
  date   DateTime
  total  Int       @default(0)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type, date])
  @@index([userId, type, date])
  @@map("daily_point_counters")
}

model CreditTransaction {
  id              String                @id @default(uuid())
  userId          String
  pitchId         String?
  type            CreditTransactionType
  amount          Int // Credits added (positive) or spent (negative)
  balanceBefore   Int
  balanceAfter    Int
  stripePaymentId String?
  description     String?
  createdAt       DateTime              @default(now())

  // Relations
  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  pitch Pitch? @relation(fields: [pitchId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([pitchId])
  @@index([type])
  @@index([createdAt])
  @@map("credit_transactions")
}

model SponsoredPitch {
  id              String   @id @default(uuid())
  userId          String // Author who purchased the sponsorship
  pitchId         String
  targetGenres    String[] @default([]) // Empty = all genres
  minMemberCount  Int? // Minimum club members (null = no limit)
  maxMemberCount  Int? // Maximum club members (null = no limit)
  targetFrequency String? // Club reading frequency filter (null = all)
  budget          Int // Total credits allocated
  creditsSpent    Int      @default(0)
  impressions     Int      @default(0) // How many times shown to clubs
  clicks          Int      @default(0) // How many times clicked
  startDate       DateTime @default(now())
  endDate         DateTime
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  pitch Pitch @relation(fields: [pitchId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([pitchId])
  @@index([isActive])
  @@index([startDate, endDate])
  @@map("sponsored_pitches")
}

model RewardItem {
  id              String     @id @default(uuid())
  name            String
  description     String?    @db.Text
  pointsCost      Int
  rewardType      RewardType @default(PLATFORM)
  contributorId   String? // Author who contributed this reward (if author_contributed)
  copiesAvailable Int? // For limited quantity items
  copiesRedeemed  Int        @default(0)
  imageUrl        String?
  isActive        Boolean    @default(true)
  sortOrder       Int        @default(0)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  contributor User?               @relation("RewardContributor", fields: [contributorId], references: [id], onDelete: SetNull)
  redemptions RedemptionRequest[]

  @@index([isActive, sortOrder])
  @@index([contributorId])
  @@map("reward_items")
}

model RedemptionRequest {
  id              String           @id @default(uuid())
  userId          String
  rewardItemId    String
  pointsSpent     Int
  status          RedemptionStatus @default(PENDING)
  reviewedBy      String? // Admin who approved/declined
  reviewedAt      DateTime?
  rejectionReason String?          @db.Text
  fulfilledAt     DateTime?
  notes           String?          @db.Text
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relations
  user       User       @relation("UserRedemptions", fields: [userId], references: [id], onDelete: Cascade)
  rewardItem RewardItem @relation(fields: [rewardItemId], references: [id], onDelete: Cascade)
  reviewer   User?      @relation("RedemptionReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([rewardItemId])
  @@index([status, createdAt])
  @@map("redemption_requests")
}

model AuthorFollow {
  id         String   @id @default(uuid())
  followerId String
  authorId   String
  createdAt  DateTime @default(now())

  // Relations
  follower User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  author   User @relation("FollowedAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@unique([followerId, authorId])
  @@index([followerId])
  @@index([authorId])
  @@map("author_follows")
}
