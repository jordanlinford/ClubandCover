generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  READER
  AUTHOR
  CLUB_ADMIN
  STAFF
}

enum Tier {
  FREE
  PRO_AUTHOR
  PRO_CLUB
  PUBLISHER
}

enum MembershipRole {
  OWNER
  ADMIN
  MEMBER
  PENDING
}

enum MembershipStatus {
  PENDING
  ACTIVE
  DECLINED
  REMOVED
}

enum SwapStatus {
  REQUESTED
  ACCEPTED
  DECLINED
  DELIVERED
  VERIFIED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum BookCondition {
  NEW
  LIKE_NEW
  VERY_GOOD
  GOOD
  ACCEPTABLE
}

enum ThreadType {
  DM
  CLUB
}

enum ReportStatus {
  PENDING
  REVIEWED
  DISMISSED
}

enum JoinRules {
  OPEN
  APPROVAL
  INVITE_ONLY
}

enum PollType {
  PITCH
  BOOK
}

enum PollStatus {
  DRAFT
  OPEN
  CLOSED
  ARCHIVED
}

enum PitchStatus {
  SUBMITTED
  ACCEPTED
  REJECTED
  ARCHIVED
}

enum PointType {
  SWAP_VERIFIED
  ON_TIME_DELIVERY
  PITCH_SELECTED
  VOTE_PARTICIPATION
  REVIEW_VERIFIED
  SOCIAL_SHARE
  HOST_ACTION
  REFERRAL_ACTIVATED
}

enum ReferralStatus {
  ISSUED
  CLAIMED
  ACTIVATED
  EXPIRED
}

enum NotificationType {
  POLL_CREATED
  POLL_CLOSING
  PITCH_ACCEPTED
  PITCH_REJECTED
  SWAP_DELIVERED
  SWAP_VERIFIED
  REFERRAL_ACTIVATED
  POINTS_AWARDED
  MEMBERSHIP_APPROVED
  NEW_MESSAGE
}

// Models
model User {
  id                   String    @id
  email                String    @unique
  name                 String
  avatarUrl            String?
  bio                  String?
  role                 UserRole  @default(READER)
  tier                 Tier      @default(FREE)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  aiCallsToday         Int       @default(0)
  aiCallsResetAt       DateTime  @default(now())
  points               Int       @default(0)
  reputation           Int       @default(0)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  profile            UserProfile?
  books              Book[]             @relation("UserBooks")
  clubsCreated       Club[]             @relation("ClubCreator")
  memberships        Membership[]
  swapsRequested     Swap[]             @relation("SwapRequester")
  swapsReceived      Swap[]             @relation("SwapResponder")
  reviewsGiven       Review[]           @relation("Reviewer")
  reviewsReceived    Review[]           @relation("Reviewee")
  payments           Payment[]
  membershipsInvited Membership[]       @relation("InvitedBy")
  threadMemberships  ThreadMember[]
  sentMessages       Message[]
  reviewedMessages   Message[]          @relation("ReviewedMessages")
  reportedMessages   ModerationReport[] @relation("ReportedMessages")
  reviewedReports    ModerationReport[] @relation("ReviewedReports")
  pitches            Pitch[]
  pitchNominations   PitchNomination[]
  pointEntries       PointLedger[]
  votes              Vote[]
  pollsCreated       Poll[]
  referralsGiven     Referral[]         @relation("ReferrerReferrals")
  referralsUsed      Referral[]         @relation("RefereeReferrals")
  notifications      Notification[]
  settings           UserSetting?
  checklistProgress  ChecklistProgress[]
  emailLogs          EmailLog[]
  clubMessages       ClubMessage[]

  @@index([role])
  @@index([tier])
  @@map("users")
}

model UserProfile {
  userId        String   @id
  genres        String[] @default([])
  booksPerMonth Int?
  bio           String?  @db.Text
  avatarUrl     String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model Book {
  id          String        @id @default(uuid())
  ownerId     String
  title       String
  subtitle    String?
  author      String
  genres      String[]      @default([])
  isbn        String?
  description String?
  condition   BookCondition @default(GOOD)
  imageUrl    String?
  isAvailable Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  owner          User         @relation("UserBooks", fields: [ownerId], references: [id], onDelete: Cascade)
  swapsOffered   Swap[]       @relation("BookOffered")
  swapsRequested Swap[]       @relation("BookRequested")
  embeddings     Embedding[]
  reviews        Review[]
  pitches        Pitch[]
  pollOptions    PollOption[]

  @@index([ownerId])
  @@index([isAvailable])
  @@map("books")
}

model Club {
  id              String   @id @default(uuid())
  name            String
  description     String?
  about           String?  @db.Text
  preferredGenres String[] @default([])
  frequency       Int?
  imageUrl        String?
  coverImageUrl   String?
  createdById     String
  maxMembers       Int       @default(50)
  isPublic         Boolean   @default(true)
  joinRules        JoinRules @default(OPEN)
  minPointsToJoin  Int       @default(0)
  chosenBookId     String?
  chosenBookAt     DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  createdBy      User            @relation("ClubCreator", fields: [createdById], references: [id])
  memberships    Membership[]
  embeddings     Embedding[]
  messageThreads MessageThread[]
  pitches        Pitch[]
  polls          Poll[]
  messages       ClubMessage[]

  @@index([createdById])
  @@index([isPublic])
  @@map("clubs")
}

model ClubMessage {
  id        String   @id @default(uuid())
  clubId    String
  userId    String
  body      String   @db.Text
  createdAt DateTime @default(now())

  // Relations
  club   Club @relation(fields: [clubId], references: [id], onDelete: Cascade)
  author User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([clubId, createdAt])
  @@map("club_messages")
}

model Membership {
  id        String           @id @default(uuid())
  userId    String
  clubId    String
  role        MembershipRole   @default(PENDING)
  status      MembershipStatus @default(PENDING)
  permissions Json?
  joinedAt    DateTime         @default(now())
  invitedBy   String?

  // Relations
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  club    Club  @relation(fields: [clubId], references: [id], onDelete: Cascade)
  inviter User? @relation("InvitedBy", fields: [invitedBy], references: [id])

  @@unique([clubId, userId])
  @@index([userId])
  @@index([clubId])
  @@index([status])
  @@map("memberships")
}

model Swap {
  id              String     @id @default(uuid())
  requesterId     String
  bookOfferedId   String
  responderId     String
  bookRequestedId String
  status          SwapStatus @default(REQUESTED)
  message         String?
  dueDate         DateTime?
  deliverable     String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  requester     User     @relation("SwapRequester", fields: [requesterId], references: [id])
  responder     User     @relation("SwapResponder", fields: [responderId], references: [id])
  bookOffered   Book     @relation("BookOffered", fields: [bookOfferedId], references: [id])
  bookRequested Book     @relation("BookRequested", fields: [bookRequestedId], references: [id])
  reviews       Review[]
  payments      Payment[]

  @@index([requesterId])
  @@index([responderId])
  @@index([bookOfferedId])
  @@index([bookRequestedId])
  @@index([status])
  @@map("swaps")
}

model Review {
  id           String   @id @default(uuid())
  reviewerId   String
  revieweeId   String
  swapId       String
  bookId       String
  rating       Int // 1-5
  comment      String?
  verifiedSwap Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Relations
  reviewer User @relation("Reviewer", fields: [reviewerId], references: [id])
  reviewee User @relation("Reviewee", fields: [revieweeId], references: [id])
  swap     Swap @relation(fields: [swapId], references: [id], onDelete: Cascade)
  book     Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([swapId, reviewerId]) // One review per swap per reviewer
  @@index([reviewerId])
  @@index([revieweeId])
  @@index([bookId])
  @@map("reviews")
}

model MessageThread {
  id        String     @id @default(uuid())
  type      ThreadType
  clubId    String?
  createdAt DateTime   @default(now())

  // Relations
  members  ThreadMember[]
  messages Message[]
  club     Club?          @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@index([clubId])
  @@index([type])
  @@map("message_threads")
}

model ThreadMember {
  id         String    @id @default(uuid())
  threadId   String
  userId     String
  joinedAt   DateTime  @default(now())
  lastReadAt DateTime?

  // Relations
  thread MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId])
  @@index([threadId])
  @@map("thread_members")
}

model Message {
  id         String    @id @default(uuid())
  threadId   String
  senderId   String
  content    String    @db.Text
  createdAt  DateTime  @default(now())
  deletedAt  DateTime?
  flaggedAt  DateTime?
  reviewedBy String?
  reviewedAt DateTime?

  // Relations
  thread   MessageThread      @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender   User               @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reviewer User?              @relation("ReviewedMessages", fields: [reviewedBy], references: [id])
  reports  ModerationReport[]

  @@index([threadId, createdAt])
  @@index([senderId])
  @@index([flaggedAt])
  @@map("messages")
}

model ModerationReport {
  id         String       @id @default(uuid())
  messageId  String
  reporterId String
  reason     String       @db.Text
  status     ReportStatus @default(PENDING)
  reviewedBy String?
  reviewedAt DateTime?
  createdAt  DateTime     @default(now())

  // Relations
  message  Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  reporter User    @relation("ReportedMessages", fields: [reporterId], references: [id])
  reviewer User?   @relation("ReviewedReports", fields: [reviewedBy], references: [id])

  @@index([messageId])
  @@index([status])
  @@index([reporterId])
  @@map("moderation_reports")
}

model Payment {
  id              String        @id @default(uuid())
  userId          String
  swapId          String?
  amount          Int // in cents
  stripePaymentId String        @unique
  plan            Tier
  status          PaymentStatus @default(PENDING)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  user User  @relation(fields: [userId], references: [id])
  swap Swap? @relation(fields: [swapId], references: [id])

  @@index([userId])
  @@index([swapId])
  @@index([status])
  @@map("payments")
}

model Embedding {
  id         String   @id @default(uuid())
  entityType String // "BOOK" or "CLUB"
  bookId     String?
  clubId     String?
  embedding  String // JSON stringified vector
  createdAt  DateTime @default(now())

  // Relations
  book Book? @relation(fields: [bookId], references: [id], onDelete: Cascade)
  club Club? @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([bookId])
  @@unique([clubId])
  @@index([entityType])
  @@map("embeddings")
}

model Pitch {
  id            String       @id @default(uuid())
  authorId      String
  bookId        String
  targetClubId  String?
  title         String
  synopsis      String?      @db.Text
  sampleUrl     String?
  status        PitchStatus  @default(SUBMITTED)
  impressions   Int          @default(0)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // Relations
  author      User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  book        Book              @relation(fields: [bookId], references: [id], onDelete: Cascade)
  targetClub  Club?             @relation(fields: [targetClubId], references: [id], onDelete: Cascade)
  pollOptions PollOption[]
  nominations PitchNomination[]

  @@index([authorId])
  @@index([bookId])
  @@index([targetClubId])
  @@index([status])
  @@map("pitches")
}

model PitchNomination {
  id        String   @id @default(uuid())
  pitchId   String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  pitch Pitch @relation(fields: [pitchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pitchId, userId])
  @@index([pitchId])
  @@index([userId])
  @@map("pitch_nominations")
}

model Poll {
  id        String     @id @default(uuid())
  clubId    String
  type      PollType
  status    PollStatus @default(DRAFT)
  opensAt   DateTime?
  closesAt  DateTime?
  createdBy String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  club    Club         @relation(fields: [clubId], references: [id], onDelete: Cascade)
  creator User         @relation(fields: [createdBy], references: [id])
  options PollOption[]
  votes   Vote[]

  @@index([clubId])
  @@index([status])
  @@index([createdBy])
  @@map("polls")
}

model PollOption {
  id      String  @id @default(uuid())
  pollId  String
  pitchId String?
  bookId  String?
  label   String

  // Relations
  poll  Poll   @relation(fields: [pollId], references: [id], onDelete: Cascade)
  pitch Pitch? @relation(fields: [pitchId], references: [id], onDelete: Cascade)
  book  Book?  @relation(fields: [bookId], references: [id], onDelete: Cascade)
  votes Vote[]

  @@index([pollId])
  @@index([pitchId])
  @@index([bookId])
  @@map("poll_options")
}

model Vote {
  id       String   @id @default(uuid())
  pollId   String
  userId   String
  optionId String
  createdAt DateTime @default(now())

  // Relations
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  user   User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  option PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId])
  @@index([userId])
  @@index([optionId])
  @@map("votes")
}

model PointLedger {
  id        String    @id @default(uuid())
  userId    String
  type      PointType
  amount    Int
  refType   String?
  refId     String?
  createdAt DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type, refType, refId])
  @@index([userId])
  @@index([type])
  @@map("point_ledger")
}

model Referral {
  id          String         @id @default(uuid())
  referrerId  String
  refereeId   String?
  code        String         @unique
  status      ReferralStatus @default(ISSUED)
  activatedAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  referrer User  @relation("ReferrerReferrals", fields: [referrerId], references: [id], onDelete: Cascade)
  referee  User? @relation("RefereeReferrals", fields: [refereeId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([code])
  @@index([status])
  @@map("referrals")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  data      Json
  readAt    DateTime?
  createdAt DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@index([createdAt])
  @@map("notifications")
}

model UserSetting {
  userId              String   @id
  emailOptIn          Boolean  @default(true)
  emailPollReminders  Boolean  @default(true)
  emailSwapUpdates    Boolean  @default(true)
  emailPointsUpdates  Boolean  @default(false)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model ChecklistProgress {
  id        String   @id @default(uuid())
  userId    String
  code      String
  stepKey   String
  doneAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, code, stepKey])
  @@index([userId, code])
  @@map("checklist_progress")
}

model EmailLog {
  id        String   @id @default(uuid())
  userId    String
  emailType String
  sentAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, emailType, sentAt])
  @@map("email_logs")
}
